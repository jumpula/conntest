
/* The payloads */

/* ID payload */
struct id_p {
  unsigned char next_payload;
  unsigned char r1[1];
  unsigned char length[2];
  unsigned char id_type;
  unsigned char protocol_id;
  unsigned char port[2];
  unsigned char data[4];
};

/* Nonce payload */
struct nonce_p {
  unsigned char next_payload;
  unsigned char r1[1];
  unsigned char length[2];
  unsigned char nonce_data[16];
};

/* KE payload */
struct ke_p {
  unsigned char next_payload;
  unsigned char r1[1];
  unsigned char length[2];
  unsigned char ke_data[128];
};

/* Transform payload */
struct transform_p {
  unsigned char next_payload;
  unsigned char r1[1];
  unsigned char length[2];
  unsigned char number;
  unsigned char id;
  unsigned char r2[2];
  unsigned char enc[4];
  unsigned char hash[4];
  unsigned char auth[4];
  unsigned char grp[4];
  unsigned char life_type[4];
  unsigned char life[4];
};

/* Proposal payload */
struct proposal_p {
  unsigned char next_payload;
  unsigned char reserved[1];
  unsigned char length[2];
  unsigned char number;
  unsigned char protocol_id;
  unsigned char spi_size;
  unsigned char n_tranforms;
  unsigned char spi[8];
};

/* SA payload */
struct sa_p {
  unsigned char next_payload;
  unsigned char reserved[1];
  unsigned char length[2];
  unsigned char doi[4];
  unsigned char sit[4];
};

/* ISAKMP payload */
struct isakmp_p {
  unsigned char icookie[8];
  unsigned char rcookie[8];
  unsigned char next_payload;
  unsigned char version;
  unsigned char mode;
  unsigned char flags;
  unsigned char message_id[4];
  unsigned char length[4];
};



#if 0
  memcpy(isakmp.icookie, neg->icookie, sizeof(neg->icookie));
  isakmp.next_payload = 1;            /* SA */
  isakmp.version = version;
  isakmp.mode = a_mode;		      /* Aggressive mode */
  isakmp.flags = flags;
  memcpy(isakmp.message_id, message_id, sizeof(message_id));
  PUT_32(isakmp.length, data_len);

  /* SA Payload */
  sa.next_payload = 0x04;	      /* KE */
  PUT_32(sa.length, (sizeof(sa) + sizeof(proposal) + sizeof(transform)));
  memcpy(sa.doi, doi, sizeof(doi));
  memcpy(sa.sit, sit, sizeof(sit));

  /* Proposal payload */
  proposal.next_payload = 0x00;	      /* NONE */
  PUT_32(proposal.length, (sizeof(proposal) + sizeof(transform)));
  proposal.number = 0x00;
  proposal.protocol_id = 0x01;
  proposal.spi_size = 0x08;
  proposal.n_tranforms = n_tranforms;
  memcpy(proposal.spi, neg->icookie, sizeof(neg->icookie));

  /* Transform payload */
  transform.next_payload = 0x00;      /* NONE */
  PUT_16(transform.length, sizeof(transform));
  transform.number = 0x00;
  transform.id = transform_id;
  memcpy(transform.enc, enc, sizeof(enc));
  memcpy(transform.hash, hash, sizeof(hash));
  memcpy(transform.auth, auth, sizeof(auth));
  memcpy(transform.grp, grp, sizeof(grp));
  memcpy(transform.life_type, life_type, sizeof(life_type));
  memcpy(transform.life, life, sizeof(life));


  /* Payloads for aggressive mode */
  if (isakmp.mode == a_mode) {
    /* KE payload */
    ke.next_payload = 0x10;	      /* Nonce */
    PUT_16(ke.length, sizeof(ke));
    /* ke.ke_data  = zeroes now for testing */

    /* Nonce payload */
    nonce.next_payload = 0x05;	      /* ID */
    PUT_16(nonce.length, sizeof(nonce));
    /* nonce.nonce_data  = zeroes now for testing */

    /* ID Payload */
    id.next_payload = 0x00;	      /* NONE */
    PUT_16(id.length, sizeof(id));
    id.id_type = 0x01;		      /* IPv4 */
    id.protocol_id = 0x17;	      /* UDP */
    PUT_16(id.port, 500);	      /* IKE 500 */
    /* id.data = zero address for now */
  }

#endif

